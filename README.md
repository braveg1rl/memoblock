# Memoblock

A nifty memory device for use with promise-chains.

## Rationale

Promises are a great innovation to reduce "right-ward drift" as seen with code using regular node-style callbacks. It also eases error handling, relieving you from the necessity to check for errors after each asynchronous step.

However, I found code that goes further than merely processing return values in a chain (comparable to a regular synchronous function chain) still to noisy and cumbersome for my tastes.

Memoblock allows you to create a memo object which can be used as the return value value in your chain. It essentially takes over the role of what normally would be the function context which different statements can share, and which may hold any number of named objects. The keys set on the memo can be seen as local function variables.

## Usage

A memo produced by Memoblock has two methods `memo.set` and `memo.get`. 

`memo.set` can be used to place either a regular value, or a promise for a value on the memo. Inside a function, you can put any number of values or promises of value on the memo, and you can mix them at will.

Every time you call `memo.set`, it returns a promise for a new Memo. When this promise resolves, the value is a new Memo with the resolved value for all promises you had previously set.

With `memo.get`, you can get the value of anything you had previously set. For convience, the values are also assigned to properties of the memo object.

### How it's better

1. No need to define var's up-front in an outer function context. You can set any value you want. Just like a regular object on which you set values.
2. No need to think about whether the value you set is a real value or rather a promise for a value. Functions that return a promise appear in the code without any added noise.
3. No need to assign any resolved value (available in the chain via first callback of "then") to a variable in the outer function context. This will save you one line of code for any value of promise you need to have available further down in the chain.

## Example

In this example, we attempt to build some kind of message piece by piece before sending it.

```coffee
Memoblock = require "memoblock"

Memoblock.makeMemo()
  .then (memo) ->
    memo.set "name", "Meryn Stol" # real
    memo.set "subject", consoleAPI.askForLine "Message subject" # promise
  .then (memo) ->
    memo.set "body", consoleAPI.askForText "Message body" # promise
    memo.set "location", locationAPI.guessFriendlyName() # promise
  .then (memo) ->
    memo.set "blurp", "\n\nWritten in #{memo.location}" # real
    memo.set "body", memo.body + memo.blurp
    memo.set "signature", signatureAPI.signMessage memo.name, memo.subject, memo.body
  .then (memo) ->
    memo.set "date", new Date
  .then (memo) ->
    memo.set "mailResult", mailerAPI.sent memo.name, memo.email, memo.body + memo.signature
  .then (memo) ->
    console.log "Successfully sent your message '#{memo.subject}' at #{memo.mailResult.getFriendlyTime()}."
  .then null, (err) ->
    console.error err
```

Note that CoffeeScript automatically uses the last statement inside a function as return value. Otherwise, imagine "return" before every last line. A little less clean, but you'd have to live with all the `function`s, parentheses and braces as well...

`Memoblock.makeMemo()` is the way to get a memo. It doesn't return a memo itself, but a promise for a memo, which means you start of your chain with `.then (memo) ->`.

You can pass an object containing a mix of regular values and promises to `Memoblock.makeMemo`. These will be used as the initial values for the memo.

## Credits

The initial structure of this module was generated by [Jumpstart](https://github.com/meryn/jumpstart), using the [Jumpstart Black Coffee](https://github.com/meryn/jumpstart-black-coffee) template.

## License

Memoblock is released under the [MIT License](http://opensource.org/licenses/MIT).  
Copyright (c) 2013 Meryn Stol  